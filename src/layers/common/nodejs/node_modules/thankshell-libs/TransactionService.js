'use strict';

const GroupDao = require('thankshell-libs/GroupDao.js');
const GroupMembersDao = require('thankshell-libs/GroupMembersDao.js');
const TransactionHistoryRepository = require('thankshell-libs/TransactionHistoryRepository.js');

const encode = (oldMemberId) => {
  switch(oldMemberId) {
    case 'sla_bank': return '__BANK__';
    case '--': return '__VOID__';
    default: return oldMemberId;
  }
}

const decode = (memberId) => {
  switch(memberId) {
    case '__BANK__': return 'sla_bank';
    case '__VOID__': return '--';
    default: return memberId;
  }
}

const convertToClassic = (record) => {
  return {
    "transaction_id": record['transaction_id'],
    "from_account": decode(record['from_member_id']),
    "to_account": decode(record['to_member_id']),
    "type": 'selan',
    "amount": record['amount'],
    "timestamp": record['timestamp'],
    "comment": record['comment'],
  };
}

module.exports = class TransactionService {
    constructor() {
        this.reserved = ['--'];
        this.transactionHistoryRepository = new TransactionHistoryRepository(process.env.TOKEN_TRANSACTIONS_TABLE_NAME);
        this.groupDao = new GroupDao();
        this.groupMembersDao = new GroupMembersDao();
    }

    async getCarried(account) {
        let carried = 0;

        const records = await this.transactionHistoryRepository.getAsync('sla', encode(account));
        const items = records.map(record => convertToClassic(record));
        items.forEach(function(data) {
            if(isFinite(data.amount)) {
                if(data.from_account == account) {
                    carried -= data.amount;
                }
                else if(data.to_account == account) {
                    carried += data.amount;
                }
            }
        }, carried);

        return carried;
    }

    async create(groupId, xdata) {
        const group = await this.groupDao.getAsync(groupId);
        const members = await this.groupMembersDao.getMembersAsync(groupId);

        if (!this.validAccount(group.bankId, members, xdata.from)) {
            throw new Error(`送金元${xdata.from}が無効です`);
        }

        if (!this.validAccount(group.bankId, members, xdata.to)) {
            throw new Error(`送金先${xdata.to}が無効です`);
        }

        if (xdata.from !== '--' && await this.getCarried(xdata.from) < xdata.amount) {
            throw new Error("所持金が不足しています");
        }

        if (xdata.from === xdata.to) {
            throw new Error("自分自身に送金しています");
        }

        if (isNaN(xdata.amount) || xdata.amount <= 0) {
            throw new Error("illigal amount: " + xdata.amount);
        }

        if(xdata.comment && xdata.comment.length > 200) {
            throw new Error("コメントが200文字を超えています");
        }

        xdata.from = encode(xdata.from);
        xdata.to = encode(xdata.to);

        let timestamp = +(new Date());
        await this.transactionHistoryRepository.insertAsync(
            'sla',
            xdata.from,
            xdata.to,
            xdata.amount,
            timestamp,
            xdata.comment ? xdata.comment : ''
        );
    }

    validAccount(bankId, members, memberId) {
        const memberIds = members.map(member => member.memberId);
        return bankId == memberId
                || this.reserved.includes(memberId)
                || memberIds.includes(memberId);
    }

    //--------------------------------------------------------------------
    // For get-token-holders

    async getHoldingsAsync() {
        const records = await this.transactionHistoryRepository.getAllAsync('sla');
        const items = records.map(record => convertToClassic(record));

        let history = {
            Count: items.length,
            Items: items
        };
        let result = {};

        history.Items.forEach((item) => {
            if(isFinite(item.amount)) {
                if (item.from_account != '--') {
                    if (!result[item.from_account]) { result[item.from_account] = 0; }
                    result[item.from_account] -= item.amount;
                }
                if (item.to_account != '--') {
                    if (!result[item.to_account]) { result[item.to_account] = 0; }
                    result[item.to_account] += item.amount;
                }
            }
        });

        return result;
    }

    async getAccountHoldingAsync(userId) {
        const records = await this.transactionHistoryRepository.getAsync('sla', encode(userId));
        const items = records.map(record => convertToClassic(record));

        let history = {
            Count: items.length,
            Items: items,
        };

        let carried = 0;

        history.Items.forEach((item) => {
            if(isFinite(item.amount)) {
                if(item.from_account == userId) {
                    carried -= item.amount;
                }
                if(item.to_account == userId) {
                    carried += item.amount;
                }
            }
        });

        return carried;
    }

    async getPublishedAsync() {
        const userId = '--';
        const records = await this.transactionHistoryRepository.getAsync('sla', encode(userId));
        const items = records.map(record => convertToClassic(record));

        let history = {
            Count: items.length,
            Items: items,
        };

        let carried = 0;

        history.Items.forEach((item) => {
            if(item.from_account == userId) {
                carried += item.amount;
            }
            if(item.to_account == userId) {
                carried -= item.amount;
            }
        });

        return carried;
    }

    async getHistoryAsync() {
        const items = await this.transactionHistoryRepository.getAllAsync();

        let history = {
            Count: items.length,
            Items: items
        };
        return history;
    }

    async getMemberHistoryAsync(userId) {
        const records = await this.transactionHistoryRepository.getAsync('sla', encode(userId));
        const items = records.map(record => convertToClassic(record));

        return {
            Count: items.length,
            Items: items,
        };
    }
}
