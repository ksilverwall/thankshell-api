'use strict';

const BANK_MEMBER_ID = '__BANK__';
const VOID_MEMBER_ID = '__VOID__';

module.exports = class TransactionService {
    constructor(groupId, groupDao, groupMembersDao, transactionHistoryRepository) {
        this.groupId = groupId;
        this.groupDao = groupDao;
        this.groupMembersDao = groupMembersDao;
        this.transactionHistoryRepository = transactionHistoryRepository;
    }

    async create(fromMemberId, toMemberId, amount, timestamp, comment) {
        const members = await this.groupMembersDao.getMembersAsync(this.groupId);
        if (!this.validAccount(members, fromMemberId)) {
            throw new Error(`送金元${fromMemberId}が無効です`);
        }

        if (!this.validAccount(members, toMemberId)) {
            throw new Error(`送金先${toMemberId}が無効です`);
        }

        if (fromMemberId !== VOID_MEMBER_ID && await this.getAccountHoldingAsync(fromMemberId) < amount) {
            throw new Error("所持金が不足しています");
        }

        if (fromMemberId === toMemberId) {
            throw new Error("自分自身に送金しています");
        }

        if (isNaN(amount) || amount <= 0) {
            throw new Error("illigal amount: " + amount);
        }

        if(comment && comment.length > 200) {
            throw new Error("コメントが200文字を超えています");
        }

        await this.transactionHistoryRepository.insertAsync(
            this.groupId,
            fromMemberId,
            toMemberId,
            amount,
            timestamp,
            comment ? comment : ''
        );
    }

    validAccount(members, memberId) {
        const memberIds = members.map(member => member.memberId);
        return [BANK_MEMBER_ID, VOID_MEMBER_ID].includes(memberId)
                || memberIds.includes(memberId);
    }

    //--------------------------------------------------------------------
    // For get-token-holders

    async getHoldingsAsync() {
        const records = await this.transactionHistoryRepository.getAllAsync(this.groupId);

        const result = records.reduce((previous, current)=>{
            const {amount, from_member_id: fromMemberId, to_member_id: toMemberId} = current;

            if(!isFinite(amount) || fromMemberId === toMemberId) {
                return previous
            }

            return Object.assign(
                previous,
                {
                    [fromMemberId]: (previous[fromMemberId] || 0) - amount,
                    [toMemberId]: (previous[toMemberId] || 0) + amount,
                }
            );
        }, {});

        delete result[VOID_MEMBER_ID];
        result['sla_bank'] = result[BANK_MEMBER_ID]
        delete result[BANK_MEMBER_ID];

        return result;
    }

    async getAccountHoldingAsync(memberId) {
        const records = await this.transactionHistoryRepository.getAsync(this.groupId, memberId);

        const carried = records.reduce((previous, current)=>{
            const {amount, from_member_id: fromMemberId, to_member_id: toMemberId} = current;

            if(!isFinite(amount) || fromMemberId === toMemberId) {
                return previous
            }
            if(fromMemberId === memberId) {
                return previous - amount;
            }
            if(toMemberId === memberId) {
                return previous + amount;
            }
        }, 0);

        return carried;
    }

    async getPublishedAsync() {
        return -this.getAccountHoldingAsync(VOID_MEMBER_ID);
    }

    async getHistoryAsync() {
        return await this.transactionHistoryRepository.getAllAsync(this.groupId);
    }

    async getMemberHistoryAsync(memberId) {
        return await this.transactionHistoryRepository.getAsync(this.groupId, memberId);
    }

    async publishAsync(amount, timestamp, comment) {
        await this.create(VOID_MEMBER_ID, BANK_MEMBER_ID, amount, timestamp, comment);
    }
}
