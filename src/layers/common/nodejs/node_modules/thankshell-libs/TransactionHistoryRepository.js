'use strict';

const AWS = require("aws-sdk");
const dynamo = new AWS.DynamoDB.DocumentClient();

const crypto = require('crypto');

const getTransactionId = (timestamp, fromMemberId, toMemberId) => {
  const hashStr = crypto.createHash('sha256').update(`${fromMemberId}:${toMemberId}`).digest("hex");

  const timeStr = '0'.repeat(16) + timestamp.toString(16);

  return `${timeStr.slice(-16)}_${hashStr.slice(-8)}`;
}

module.exports = class TransactionHistoryRepository {
  constructor(tableName) {
    this.tableName = tableName;
  }

  async getAsync(groupId, memberId) {
    const result = await dynamo.query({
      TableName: this.tableName,
      KeyConditionExpression: "group_id = :group_id",
      FilterExpression: "from_member_id = :member_id or to_member_id = :member_id",
      ExpressionAttributeValues: {
        ":group_id": groupId,
        ":member_id": memberId,
      }
    }).promise();

    return result.Items;
  }

  async getAllAsync(groupId) {
    const result = await dynamo.query({
      TableName: this.tableName,
      KeyConditionExpression: "group_id = :group_id",
      ExpressionAttributeValues: {
        ":group_id": groupId,
      }
    }).promise();

    return result.Items;
  }

  async insertAsync(groupId, fromMemberId, toMemberId, amount, timestamp, commnet) {
    await dynamo.put({
      TableName: this.tableName,
      Item: {
        'group_id': groupId,
        'transaction_id': getTransactionId(timestamp, fromMemberId, toMemberId),
        'from_member_id': fromMemberId,
        'to_member_id': toMemberId,
        'amount': amount,
        'timestamp': timestamp,
        'comment': commnet,
      }
    }).promise();
  }
}
