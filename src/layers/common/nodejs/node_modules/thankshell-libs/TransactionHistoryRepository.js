'use strict';

const AWS = require("aws-sdk");
const dynamo = new AWS.DynamoDB.DocumentClient();

const crypto = require('crypto');

const getTransactionId = (timestamp, fromMemberId, toMemberId) => {
  const hashStr = crypto.createHash('sha256').update(`${fromMemberId}:${toMemberId}`).digest("hex");

  const timeStr = '0'.repeat(16) + timestamp.toString(16);

  return `${timeStr.slice(-16)}_${hashStr.slice(-8)}`;
}

const encode = (oldMemberId) => {
  switch(oldMemberId) {
    case 'sla_bank': return '__BANK__';
    case '--': return '__VOID__';
    default: return oldMemberId;
  }
}

const decode = (memberId) => {
  switch(memberId) {
    case '__BANK__': return 'sla_bank';
    case '__VOID__': return '--';
    default: return memberId;
  }
}

const convertToClassic = (record) => {
  return {
    "transaction_id": record['transaction_id'],
    "from_account": decode(record['from_member_id']),
    "to_account": decode(record['to_member_id']),
    "type": 'selan',
    "amount": record['amount'],
    "timestamp": record['timestamp'],
    "comment": record['comment'],
  };
}

module.exports = class TransactionHistoryRepository {
  constructor() {
    this.tableName = process.env.TOKEN_TRANSACTIONS_TABLE_NAME;
  }

  async getAsync(memberId) {
    const groupId = 'sla';
    const result = await dynamo.query({
      TableName: this.tableName,
      KeyConditionExpression: "group_id = :group_id",
      FilterExpression: "from_member_id = :member_id or to_member_id = :member_id",
      ExpressionAttributeValues: {
        ":group_id": groupId,
        ":member_id": encode(memberId),
      }
    }).promise();

    return result.Items.map(record => convertToClassic(record));
  }

  async getAllAsync() {
    const groupId = 'sla';
    const result = await dynamo.query({
      TableName: this.tableName,
      KeyConditionExpression: "group_id = :group_id",
      ExpressionAttributeValues: {
        ":group_id": groupId,
      }
    }).promise();

    return result.Items.map(record => convertToClassic(record));
  }

  async insertAsync(xdata, timestamp) {
    const groupId = 'sla';
    const currentData = await dynamo.get({
      TableName: process.env.TABLE_INFO_TABLE_NAME,
      Key:{
        'name': process.env.REMITTANCE_TRANSACTIONS,
      },
    }).promise();

    if (!currentData.Item) {
      await dynamo.put({
        TableName: process.env.TABLE_INFO_TABLE_NAME,
        Item: {
          'name': process.env.REMITTANCE_TRANSACTIONS,
          'current_id_sequence': 0
        },
      }).promise();
    }

    const data = await dynamo.update({
      TableName: process.env.TABLE_INFO_TABLE_NAME,
      Key:{
        'name': process.env.REMITTANCE_TRANSACTIONS,
      },
      UpdateExpression: "set current_id_sequence = current_id_sequence + :val",
      ExpressionAttributeValues:{
        ":val": 1,
      },
      ReturnValues:"UPDATED_NEW"
    }).promise();

    const sequence = data.Attributes.current_id_sequence;

    const item = {
      "block_id": Math.floor(sequence / 1000),
      "transaction_id": sequence,
      "from_account": xdata.from,
      "to_account": xdata.to,
      "type": xdata.token,
      "amount": xdata.amount,
      "timestamp": timestamp,
      "comment": xdata.comment ? xdata.comment : ' ',
    };
    await dynamo.put({
      TableName: process.env.REMITTANCE_TRANSACTIONS,
      Item: item
    }).promise();

    await dynamo.put({
      TableName: this.tableName,
      Item: {
        'group_id': groupId,
        'transaction_id': getTransactionId(timestamp, xdata.from, xdata.to),
        'from_member_id': encode(xdata.from),
        'to_member_id': encode(xdata.to),
        'amount': xdata.amount,
        'timestamp': timestamp,
        'comment': xdata.comment ? xdata.comment : '',
      }
    }).promise();
  }
}
