const AWS = require("aws-sdk");
const dynamo = new AWS.DynamoDB.DocumentClient();

const getGroupInfo = async(groupId) => {
    let data = await dynamo.get({
        TableName: process.env.GROUPS_TABLE_NAME,
            Key:{
                'group_id': groupId,
            }
    }).promise();

    return data.Item;
};

module.exports = class TransactionsDao {
    constructor() {
        this.tableInfo = {
            'info': process.env.TABLE_INFO_TABLE_NAME,
            'data': process.env.REMITTANCE_TRANSACTIONS,
        };
        this.reserved = ['--'];
    }

    async getCarried(account) {
        let info = await dynamo.get({
            TableName: this.tableInfo['info'],
            Key:{
                'name': this.tableInfo['data'],
            }
        }).promise();
        let maxBlockId = Math.floor(info.Item.current_id_sequence / 1000);

        // Get History
        var history = {
            Count: 0,
            Items: []
        };

        for (var blockId=maxBlockId; blockId >= 0; --blockId) {
            var data = await dynamo.query({
                TableName: this.tableInfo['data'],
                KeyConditionExpression: "block_id = :block",
                FilterExpression: "from_account = :account or to_account = :account",
                ExpressionAttributeValues: {
                    ":block": blockId,
                    ":account": account
                }
            }).promise();
            history.Items = history.Items.concat(data.Items);
            history.Count += data.Count;
        }

        // Get Carried
        var carried = 0;
        history.Items.forEach(function(data) {
            if(isFinite(data.amount)) {
                if(data.from_account == account) {
                    carried -= data.amount;
                }
                else if(data.to_account == account) {
                    carried += data.amount;
                }
            }
        }, carried);

        return carried;
    }

    async create(groupId, xdata) {
        const groupInfo = await getGroupInfo(groupId);
        let date = +(new Date());

        if (!this.validAccount(groupInfo, xdata.from)) {
            throw new Error(`送金元${xdata.from}が無効です`);
        }

        if (!this.validAccount(groupInfo, xdata.to)) {
            throw new Error(`送金先${xdata.to}が無効です`);
        }

        if (await this.getCarried(xdata.from) < xdata.amount) {
            throw new Error("所持金が不足しています");
        }

        if (xdata.from === xdata.to) {
            throw new Error("自分自身に送金しています");
        }

        if (isNaN(xdata.amount) || xdata.amount <= 0) {
            throw new Error("illigal amount: " + xdata.amount);
        }

        if(xdata.comment && xdata.comment.length > 200) {
            throw new Error("コメントが200文字を超えています");
        }

        let sequence = await this._incrementSequence();
        let item = {
            "block_id": Math.floor(sequence / 1000),
            "transaction_id": sequence,
            "from_account": xdata.from,
            "to_account": xdata.to,
            "type": xdata.token,
            "amount": xdata.amount,
            "timestamp": date,
            "comment": xdata.comment ? xdata.comment : ' ',
        };
        await this._save(item);
    }

    async _incrementSequence() {
        let currentData = await dynamo.get({
            TableName: this.tableInfo['info'],
            Key:{
                'name': this.tableInfo['data'],
            },
        }).promise();

        if (!currentData.Item) {
            await dynamo.put({
                TableName: this.tableInfo['info'],
                Item: {
                    'name': this.tableInfo['data'],
                    'current_id_sequence': 0
                },
            }).promise();
        }

        let data = await dynamo.update({
            TableName: this.tableInfo['info'],
            Key:{
                'name': this.tableInfo['data'],
            },
            UpdateExpression: "set current_id_sequence = current_id_sequence + :val",
            ExpressionAttributeValues:{
                ":val":1
            },
            ReturnValues:"UPDATED_NEW"
        }).promise();

        return data.Attributes.current_id_sequence;
    }

    async _save(item) {
        return await dynamo.put({
            TableName: this.tableInfo['data'],
            Item: item
        }).promise();
    }

    validAccount(groupInfo, account) {
        return groupInfo.bank_id == account
                || this.reserved.includes(account)
                || groupInfo.members.values.includes(account);
    }
}
