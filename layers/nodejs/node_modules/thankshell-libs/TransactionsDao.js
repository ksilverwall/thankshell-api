const AWS = require("aws-sdk");
const GroupDao = require('thankshell-libs/GroupDao.js');
const GroupMembersDao = require('thankshell-libs/GroupMembersDao.js');

const dynamo = new AWS.DynamoDB.DocumentClient();

const getHistory = async() => {
    let adminMode = false;

    let history = {
        Count: 0,
        Items: []
    };

    let tableInfo = await dynamo.get({
        TableName: process.env.TABLE_INFO_TABLE_NAME,
        Key:{
            'name': process.env.REMITTANCE_TRANSACTIONS,
        }
    }).promise();

    let maxBlockId = tableInfo.Item ? Math.floor(tableInfo.Item.current_id_sequence / 1000) : 0;

    for (let blockId=maxBlockId; blockId >= 0; --blockId) {
        let params;
        if(adminMode) {
            params = {
                TableName: process.env.REMITTANCE_TRANSACTIONS,
                KeyConditionExpression: "block_id = :block",
                ExpressionAttributeValues: {
                    ":block": blockId
                }
            };
        } else {
            params = {
                TableName: process.env.REMITTANCE_TRANSACTIONS,
                KeyConditionExpression: "block_id = :block",
                ExpressionAttributeValues: {
                    ":block": blockId,
                }
            };
        }

        var data = await dynamo.query(params).promise();
        history.Items = history.Items.concat(data.Items);
        history.Count += data.Count;
    }

    return history;
};

const getUserHistory = async(account) => {
    let adminMode = false;

    let history = {
        Count: 0,
        Items: []
    };

    let tableInfo = await dynamo.get({
        TableName: process.env.TABLE_INFO_TABLE_NAME,
        Key:{
            'name': process.env.REMITTANCE_TRANSACTIONS,
        }
    }).promise();

    let maxBlockId = tableInfo.Item ? Math.floor(tableInfo.Item.current_id_sequence / 1000) : 0;

    for (let blockId=maxBlockId; blockId >= 0; --blockId) {
        let params;
        if(adminMode) {
            params = {
                TableName: process.env.REMITTANCE_TRANSACTIONS,
                KeyConditionExpression: "block_id = :block",
                ExpressionAttributeValues: {
                    ":block": blockId
                }
            };
        } else {
            params = {
                TableName: process.env.REMITTANCE_TRANSACTIONS,
                KeyConditionExpression: "block_id = :block",
                FilterExpression: "from_account = :account or to_account = :account",
                ExpressionAttributeValues: {
                    ":block": blockId,
                    ":account": account
                }
            };
        }

        var data = await dynamo.query(params).promise();
        history.Items = history.Items.concat(data.Items);
        history.Count += data.Count;
    }

    return history;
};

module.exports = class TransactionsDao {
    constructor() {
        this.tableInfo = {
            'info': process.env.TABLE_INFO_TABLE_NAME,
            'data': process.env.REMITTANCE_TRANSACTIONS,
        };
        this.reserved = ['--'];
    }

    async getCarried(account) {
        let info = await dynamo.get({
            TableName: this.tableInfo['info'],
            Key:{
                'name': this.tableInfo['data'],
            }
        }).promise();
        let maxBlockId = Math.floor(info.Item.current_id_sequence / 1000);

        // Get History
        var history = {
            Count: 0,
            Items: []
        };

        for (var blockId=maxBlockId; blockId >= 0; --blockId) {
            var data = await dynamo.query({
                TableName: this.tableInfo['data'],
                KeyConditionExpression: "block_id = :block",
                FilterExpression: "from_account = :account or to_account = :account",
                ExpressionAttributeValues: {
                    ":block": blockId,
                    ":account": account
                }
            }).promise();
            history.Items = history.Items.concat(data.Items);
            history.Count += data.Count;
        }

        // Get Carried
        var carried = 0;
        history.Items.forEach(function(data) {
            if(isFinite(data.amount)) {
                if(data.from_account == account) {
                    carried -= data.amount;
                }
                else if(data.to_account == account) {
                    carried += data.amount;
                }
            }
        }, carried);

        return carried;
    }

    async create(groupId, xdata) {
        const groupDao = new GroupDao();
        const group = await groupDao.getAsync(groupId);

        const groupMembersDao = new GroupMembersDao();
        const members = await groupMembersDao.getMembersAsync(groupId);

        let date = +(new Date());

        if (!this.validAccount(group.bankId, members, xdata.from)) {
            throw new Error(`送金元${xdata.from}が無効です`);
        }

        if (!this.validAccount(group.bankId, members, xdata.to)) {
            throw new Error(`送金先${xdata.to}が無効です`);
        }

        if (xdata.from !== '--' && await this.getCarried(xdata.from) < xdata.amount) {
            throw new Error("所持金が不足しています");
        }

        if (xdata.from === xdata.to) {
            throw new Error("自分自身に送金しています");
        }

        if (isNaN(xdata.amount) || xdata.amount <= 0) {
            throw new Error("illigal amount: " + xdata.amount);
        }

        if(xdata.comment && xdata.comment.length > 200) {
            throw new Error("コメントが200文字を超えています");
        }

        let sequence = await this._incrementSequence();
        let item = {
            "block_id": Math.floor(sequence / 1000),
            "transaction_id": sequence,
            "from_account": xdata.from,
            "to_account": xdata.to,
            "type": xdata.token,
            "amount": xdata.amount,
            "timestamp": date,
            "comment": xdata.comment ? xdata.comment : ' ',
        };
        await this._save(item);
    }

    async _incrementSequence() {
        let currentData = await dynamo.get({
            TableName: this.tableInfo['info'],
            Key:{
                'name': this.tableInfo['data'],
            },
        }).promise();

        if (!currentData.Item) {
            await dynamo.put({
                TableName: this.tableInfo['info'],
                Item: {
                    'name': this.tableInfo['data'],
                    'current_id_sequence': 0
                },
            }).promise();
        }

        let data = await dynamo.update({
            TableName: this.tableInfo['info'],
            Key:{
                'name': this.tableInfo['data'],
            },
            UpdateExpression: "set current_id_sequence = current_id_sequence + :val",
            ExpressionAttributeValues:{
                ":val":1
            },
            ReturnValues:"UPDATED_NEW"
        }).promise();

        return data.Attributes.current_id_sequence;
    }

    async _save(item) {
        return await dynamo.put({
            TableName: this.tableInfo['data'],
            Item: item
        }).promise();
    }

    validAccount(bankId, members, account) {
        return bankId == account
                || this.reserved.includes(account)
                || members.includes(account);
    }

    //--------------------------------------------------------------------
    // For get-token-holders

    async getHoldingsAsync() {
        let history = await getHistory();
        let result = {};

        history.Items.forEach((item) => {
            if(isFinite(item.amount)) {
                if (item.from_account != '--') {
                    if (!result[item.from_account]) { result[item.from_account] = 0; }
                    result[item.from_account] -= item.amount;
                }
                if (item.to_account != '--') {
                    if (!result[item.to_account]) { result[item.to_account] = 0; }
                    result[item.to_account] += item.amount;
                }
            }
        });

        return result;
    }

    async getAccountHoldingAsync(userId) {
        const history = await getUserHistory(userId);
        const carried = 0;

        history.Items.forEach((item) => {
            if(isFinite(item.amount)) {
                if(item.from_account == userId) {
                    carried -= item.amount;
                }
                if(item.to_account == userId) {
                    carried += item.amount;
                }
            }
        });

        return carried;
    }

    async getPublishedAsync() {
        const userId = '--';
        let history = await getUserHistory(userId);
        let carried = 0;

        history.Items.forEach((item) => {
            if(item.from_account == userId) {
                carried += item.amount;
            }
            if(item.to_account == userId) {
                carried -= item.amount;
            }
        });

        return carried;
    }

    async getHistoryAsync() {
        return await getHistory();
    }

    async getMemberHistoryAsync(userId) {
        return await getUserHistory(userId);
    }
}
