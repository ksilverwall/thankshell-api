const AWS = require("aws-sdk");
const GroupMemberPermission = require('thankshell-libs/GroupMemberPermission.js');
const appInterface = require('thankshell-libs/interface.js');

const dynamo = new AWS.DynamoDB.DocumentClient();

const setMember = async(gid, members) => {
  await dynamo.update({
    TableName: process.env.GROUPS_TABLE_NAME,
    Key:{
      'group_id': gid,
    },
    UpdateExpression: 'set members = :members',
    ExpressionAttributeValues: {
      ':members': dynamo.createSet(members)
    }
  }).promise();
}

const loadMembers = async(gid) => {
  const data = await dynamo.get({
    TableName: process.env.GROUPS_TABLE_NAME,
    Key:{
      'group_id': gid,
    },
  }).promise();

  return data.Item.members.values
};

const getGroupAsync = async(groupId) => {
  const result = await dynamo.get({
    TableName: process.env.GROUPS_TABLE_NAME,
    Key:{
      'group_id': groupId,
    }
  }).promise();

  return result.Item;
};

const getUser = async(userId) => {
  const result = await dynamo.get({
    TableName: process.env.USERS_TABLE_NAME,
    Key:{
      'user_id': userId,
    },
  }).promise()

  return result.Item
};

module.exports = class GroupMembersDao {
  async addAsync(groupId, memberId) {
    let members = await loadMembers(groupId)
    if (members.includes(memberId)) {
      throw new appInterface.ApplicationError(`'${memberId}' already registered`)
    }
    members.push(memberId)

    await setMember(groupId, members)
  }

  async deleteAsync(groupId, memberId) {
    const data = await dynamo.get({
      TableName: process.env.GROUPS_TABLE_NAME,
      Key:{
          'group_id': groupId,
      },
    }).promise();

    const members = data.Item.members;
    const filteredMembers = members.values.filter(uid => uid != memberId);

    await dynamo.update({
      TableName: process.env.GROUPS_TABLE_NAME,
      Key:{
          'group_id': groupId,
      },
      UpdateExpression: 'set members = :members',
      ExpressionAttributeValues: {
          ':members': dynamo.createSet(filteredMembers)
      }
    }).promise();
  }

  async entryAsync(groupId, memberId, authId) {
    // FIXME: set memberId related with groupId
    const result = memberId.match(/^\w+$/g)
    if (!result) {
      throw new appInterface.ApplicationError(
        "IDには英数字を指定してください",
        "INVALID_MEMBERID_FORMAT",
        403,
      )
    }

    const group = await getGroupAsync(groupId)
    if (!group.members.values.includes(memberId)) {
      throw new appInterface.ApplicationError(
        `'${groupId}'の招待リストに'${userId}'を見つけられませんでした`,
        "NO_MEMBERID_IN_LIST",
        403,
      )
    }

    // FIXME: set memberId related with groupId
    const userInfo = await getMemberAsync(groupId, await this.findMemberIdByAuthIdAsync(groupId, authId));
    if(userInfo.status != 'UNREGISTERED') {
      throw new appInterface.ApplicationError(
        `ユーザはすでに登録されています(${userInfo.user_id})`,
        "ALREADY_MEMBER_USER",
        403,
      )
    }

    // FIXME: set memberId related with groupId
    if (await getUser(memberId)) {
      throw new appInterface.ApplicationError(
        "指定のMemberIDは既に登録されています",
        "ALREADY_REGISTERD_MEMBERID",
        403,
      )
    }

    await dynamo.put({
      TableName: process.env.USERS_TABLE_NAME,
      Item: {
        user_id: memberId,
        status: 'ENABLE',
      }
    }).promise()

    await dynamo.update({
      TableName: process.env.AUTH_TABLE_NAME,
      Key:{
        'auth_id': authId,
      },
      UpdateExpression: 'SET user_id = :value',
      ExpressionAttributeValues: {
        ':value': memberId,
      },
    }).promise()
  }

  async updateAsync(groupId, authId, userId, user) {
    console.log(`Update user: ${userId}`)
    console.log(`Update data: ${user}`)

    if (userId !== await this.findMemberIdByAuthIdAsync('sla', authId)) {
      throw new appInterface.ApplicationError('No access permission', "MEMBER_NOT_FOUND", 400);
    }

    await dynamo.update({
      TableName: process.env.USERS_TABLE_NAME,
      Key:{
          'user_id': userId,
      },
      UpdateExpression: 'SET display_name = :display_name',
      ExpressionAttributeValues: {
          ':display_name': user.displayName,
      },
    }).promise()
  }

  async findGroupsByAuthIdAsync(authId) {
    const userId = await this.findMemberIdByAuthIdAsync('sla', authId);
    const data = await dynamo.scan({
      TableName: process.env.GROUPS_TABLE_NAME,
      ProjectionExpression: "group_id",
      FilterExpression: "contains(#members, :user_id)",
      ExpressionAttributeNames:{
          '#members': 'members'
      },
      ExpressionAttributeValues: {
          ":user_id": userId,
      }
    }).promise();

    return data.Items.map(record => record.group_id);
  }

  async findMemberByAuthIdAsync(groupId, authId) {
    const memberId = await this.findMemberIdByAuthIdAsync(groupId, authId);
    const group = await getGroupAsync(groupId);

    let permission = GroupMemberPermission.VISITOR;
    if (group.members.values.includes(memberId)) {
      permission = GroupMemberPermission.MEMBER;
    }
    if (group.admins.values.includes(memberId)) {
      permission = GroupMemberPermission.ADMIN;
    }

    return {
      memberId: memberId,
      permission: permission,
    }
  }

  async getMemberAsync(groupId, userId) {
    if (userId) {
      const result = await dynamo.get({
          TableName: process.env.USERS_TABLE_NAME,
          Key:{
              'user_id': userId,
          },
      }).promise();

      if (result.Item) {
          const {status, user_id, display_name} = result.Item;
          return {
              status: status,
              memberId: user_id,
              user_id: user_id,
              displayName: display_name ? display_name : user_id,
          };
      }
    };

    return {
        status: 'UNREGISTERED',
        'memberId': userId,
        'user_id': userId,
        'displayName': userId,
    };
  }

  async findMemberIdByAuthIdAsync(groupId, authId) {
    const result = await dynamo.get({
      TableName: process.env.AUTH_TABLE_NAME,
      Key:{
        'auth_id': authId,
      },
    }).promise()

    return result.Item ? result.Item['user_id'] : null
  }

  async getAdminsAsync(groupId) {
    const result = await dynamo.get({
      TableName: process.env.GROUPS_TABLE_NAME,
      Key:{
        'group_id': groupId,
      },
    }).promise()

    if (!result.Item) {
      return []
    }
    return result.Item.admins;
  }

  async getOwnerAsync(groupId) {
    const result = await dynamo.get({
      TableName: process.env.GROUPS_TABLE_NAME,
      Key:{
        'group_id': groupId,
      },
    }).promise()

    if (!result.Item) {
      return []
    }
    return result.Item.owner;
  }

  async getMembersAsync(groupId) {
    const result = await dynamo.get({
      TableName: process.env.GROUPS_TABLE_NAME,
      Key:{
        'group_id': groupId,
      },
    }).promise();

    if (!result.Item) {
      return []
    }

    const memberIds = result.Item.members.values
    const groupMembersDao = new GroupMembersDao();

    return await Promise.all(memberIds.map(memberId => groupMembersDao.getMemberAsync(groupId, memberId)))
  }
};
